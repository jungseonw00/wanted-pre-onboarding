## Week 1-1 
하루만에 완성하는 객체지향과 SOLID의 이론 복습

### 1. 코드로 보는 객체지향과 SOLID

### 2. 객체지향 세계의 3대장; 협력, 책임, 역할

### 3. 코드 재사용의 함정; 상속
1) 캡슐화 규칙을 위반 해야한다. (상속을 제대로 활용하기 위해서는 내부 구현을 알아야함)
2) 부모 클래스와 자식 클래스간 강한 결합이 생긴다. (부모 클래스의 내부 구현이 변경되면 자식 클래스 또한 변경의 영향을 받음)
   - SOLID 규칙을 지키면서 코드를 작성하는 이유가 변경에 유연하기 대응하기 위함인데, 의미가 없어짐
   - 상속은 부모의 모든 것을 받는다. (상속은.. 재산도... 빚도 다 가져야만 가질 수 있습니다..)
3) 그럼 상속은 무조건 나쁜 것인가? -> NO. 개념적으로 명확하게 is-a 관계에 있는 경우, 상위 클래스가 확장할 목적으로 설계되었다면 사용해도 괜찮다.(그러나 대부분 상속은 사용하지 않는다.) 

### 4. 유연한 코드로 가는 길; 합성, 위임
1. 합성
    - 런타임 시점에 적절하게 선택하여 주입하는 구조 
        * 런타임 시점: (Spring이 돌아가고 있고 실행되고있는 순간)
    - 역할(인터페이스)에 의존하는 것
    - 전략패턴을 공부해보기
2. 위임 

### 5. 객체의 영원한 친구; 의존성 관리하기
- A를 의존한다 = A의 정보를 알고있다.(A를 잘 알고 있다 = 높은 의존성을 가짐)

### 6. 새로운 문법; 람다
- 정의: 클래스 선언 없이 메서드를 정의할 수 있고, 값처럼 사용할 수 있는 함수(= 자바 세상에서는 메서드)
- 요즘은 람다 스타일로 코딩을 하는 추세이다.(NULL SAFETY가 가장 큰 장점)
- 일급 시민 객체 : 함수도 값(Value)으로 취급한다. (변수, 파라미터, 리턴값으로)
  - 람다 표현식을 사용하는 이유: 간결성, 익명 클래스 대체
- 람다식 문법: 람다 표현식에서 업그레이드 된 형식
  - String::valueOf == String.valueOf, s::substring == s.substring()

### 부록
- 결합도가 높다. -> 변경시 다른 객체도 연쇄적으로 변경이 필요하다.
- 파이프라인: stream은 파이프라인(=배관)에 리스트의 Element들을 전달한다.
